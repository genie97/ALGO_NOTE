## 그리디

- 탐욕법
- 현재 상황에서 가장 좋은 것을 고르는 방법

- 대표적인 그리디 문제 [거스름돈]

  ```c++
  #include<cstdio>
  int en[6] = {500, 100, 50, 10, 5, 1 };
  int main() {
  	int m;
  	scanf("%d", &m);
  	int c = 1000 - m;
  	int sum = 0;
  	for (int i = 0; i < 6; i++) {
  		while (c - en[i] >= 0) {
  			c -= en[i];
  			sum++;
  			if (c == 0)
  				break;
  		}
  	}
  	printf("%d\n", sum);
  }
  ```

  - 알고리즘의 시간 복잡도는 O(K) , K는 화폐의 종류 수

- 그리디 알고리즘의 정당성

  - 정확한 답을 찾을 수 있다는 보장이 있어야 한다
  - 거스름돈 문제의 경우, 모든 화폐 단위가 배수 관계에 있기 때문에 큰 화폐 단위부터 거슬러줘도 된다